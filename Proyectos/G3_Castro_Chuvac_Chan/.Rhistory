# --- Frontera eficiente (para gráfico) ---
frontier_df <- tibble(volatility = numeric(), return = numeric())
for (target in seq(min_ret, max_ret, length.out = 30)) {
Aeq_f <- cbind(rep(1, n_assets), mu)
beq_f <- c(1, target)
Amat_f <- cbind(Aeq_f, diag(n_assets))
bvec_f <- c(beq_f, rep(0, n_assets))
sol <- try(solve.QP(Dmat, dvec, Amat_f, bvec_f, meq = 2), silent = TRUE)
if (inherits(sol, "try-error")) next
w <- sol$solution
ret <- sum(w * mu)
vol <- sqrt(t(w) %*% Sigma %*% w)
frontier_df <- bind_rows(frontier_df, tibble(volatility = vol, return = ret))
}
# --- Activos individuales ---
assets_df <- tibble(
asset = tickers,
volatility = sqrt(diag(Sigma)),
return = mu
)
# --- Resultados ---
list(
tickers = tickers,
assets_df = assets_df,
frontier_df = frontier_df,
w_sharpe = best_w,
ret_sharpe = best_ret,
vol_sharpe = best_vol,
sharpe_ratio = best_sharpe,
w_minvar = w_minvar,
ret_minvar = ret_minvar,
vol_minvar = vol_minvar,
rf = rf
)
})
})
# Gráfico interactivo
output$frontier_plot <- renderPlotly({
req(portfolio_optimization())
res <- portfolio_optimization()
# CML
cml_df <- tibble(
volatility = c(0, res$vol_sharpe * 1.5),
return = c(res$rf, res$rf + res$sharpe_ratio * res$vol_sharpe * 1.5)
)
p <- ggplot() +
geom_line(data = res$frontier_df, aes(volatility, return), color = "steelblue", size = 1.1) +
geom_point(data = res$assets_df, aes(volatility, return, text = asset), color = "black", size = 3) +
geom_point(aes(x = res$vol_minvar, y = res$ret_minvar), color = "red", size = 4, shape = 17) +
geom_point(aes(x = res$vol_sharpe, y = res$ret_sharpe), color = "green", size = 4, shape = 17) +
geom_line(data = cml_df, aes(volatility, return), color = "purple", linetype = "dashed") +
labs(
title = "Frontera Eficiente",
x = "Volatilidad (Riesgo Anualizado)",
y = "Rendimiento Esperado (Anualizado)",
subtitle = paste("Sharpe Ratio:", round(res$sharpe_ratio, 2))
) +
scale_x_continuous(labels = scales::percent_format()) +
scale_y_continuous(labels = scales::percent_format()) +
theme_minimal()
ggplotly(p, tooltip = "text") %>%
layout(hovermode = "closest")
})
# Tabla de pesos
output$weights_table <- renderDT({
req(portfolio_optimization())
res <- portfolio_optimization()
weights_df <- tibble(
Activo = res$tickers,
`Peso Máx. Sharpe` = round(res$w_sharpe, 4),
`Peso Mín. Varianza` = round(res$w_minvar, 4)
) %>%
arrange(desc(`Peso Máx. Sharpe`))
datatable(weights_df, options = list(pageLength = 10))
})
# Estadísticas
output$stats <- renderText({
req(portfolio_optimization())
res <- portfolio_optimization()
paste(
"Portafolio de Máximo Sharpe:\n",
"- Rendimiento esperado:", round(res$ret_sharpe * 100, 2), "%\n",
"- Volatilidad:", round(res$vol_sharpe * 100, 2), "%\n",
"- Sharpe Ratio:", round(res$sharpe_ratio, 3), "\n\n",
"Portafolio de Mínima Varianza:\n",
"- Rendimiento esperado:", round(res$ret_minvar * 100, 2), "%\n",
"- Volatilidad:", round(res$vol_minvar * 100, 2), "%"
)
})
}
# Run the application
shinyApp(ui = ui, server = server)
lm(list=ls)
# app.R
# ------------------------------------------------------------
# App Shiny: Optimizador de Portafolios Óptimos
# Incluye Simulación de Monte Carlo y Análisis de Pesos
# ------------------------------------------------------------
library(shiny)
library(tidyverse)
library(tidyquant)
library(quadprog)
library(plotly)
library(DT)
library(RColorBrewer) # Para paletas de color en Monte Carlo
# Cargar lista de activos
source("R/assets.R")
# UI ----------------------------------------------------------
ui <- fluidPage(
# Estilos CSS simples para un look moderno
tags$head(
tags$style(HTML("
.btn-primary {
background-color: #3b82f6;
border-color: #3b82f6;
}
.btn-primary:hover {
background-color: #2563eb;
border-color: #2563eb;
}
.main-panel {
padding: 20px;
background-color: #f9fafb;
border-radius: 0.5rem;
box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
}
.sidebar-panel {
background-color: #ffffff;
border-radius: 0.5rem;
padding: 15px;
box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
}
h4 {
color: #1e40af; /* Azul oscuro */
font-weight: bold;
}
"))
),
titlePanel("Optimizador de Portafolios Óptimos (Modelo Markowitz)"),
sidebarLayout(
# Panel izquierdo: controles
sidebarPanel(
class = "sidebar-panel",
h4("Configuración del Análisis"),
# Selección de activos
selectInput(
inputId = "tickers",
label = "Selecciona activos (mínimo 2):",
choices = TICKER_LABELS, # Usamos la lista del archivo R/assets.R
selected = c("SPY", "TLT", "GLD", "EFA"),
multiple = TRUE
),
# Fecha de inicio
dateInput(
inputId = "from_date",
label = "Fecha de inicio:",
value = "2018-01-01"
),
# Tasa libre de riesgo
numericInput(
inputId = "rf",
label = "Tasa libre de riesgo (% anual):",
value = 2,
min = 0,
max = 10,
step = 0.1
),
# Botón de acción
actionButton("go", "Optimizar y Simular", class = "btn-primary"),
# Mensaje de estado
verbatimTextOutput("status")
),
# Panel derecho: salida
mainPanel(
class = "main-panel",
tabsetPanel(
tabPanel("Gráfico de Frontera (con Monte Carlo)", plotlyOutput("frontier_plot", height = "650px")),
tabPanel("Pesos del Portafolio Óptimo", DTOutput("weights_table")),
tabPanel("Distribución de Pesos Clave", plotlyOutput("mc_weights_plot", height = "650px")), # Nueva pestaña
tabPanel("Estadísticas Clave", verbatimTextOutput("stats"))
)
)
)
)
# Server ------------------------------------------------------
server <- function(input, output, session) {
# Función para calcular rendimientos, optimizar y simular
portfolio_optimization <- reactive({
req(input$go >= 1) # Solo ejecuta tras clic en "Optimizar"
isolate({
# Validaciones y variables
tickers <- input$tickers
if (length(tickers) < 2) {
showNotification("Selecciona al menos 2 activos.", type = "error")
return(NULL)
}
from_date <- input$from_date
rf <- input$rf / 100 # convertir % a decimal
n_assets <- length(tickers)
# Mensaje de estado: Descargar datos
output$status <- renderText({ "Descargando datos..." })
# Descargar datos
prices <- tryCatch({
tq_get(
tickers,
from = from_date,
to = Sys.Date(),
get = "stock.prices"
) %>%
select(symbol, date, adjusted)
}, error = function(e) {
showNotification("Error al descargar datos. Intenta con menos activos o fechas distintas.", type = "error")
return(NULL)
})
if (is.null(prices)) return(NULL)
# Mensaje de estado: Preparar datos
output$status <- renderText({ "Preparando datos y realizando cálculos de Markowitz..." })
# Pivotear y calcular rendimientos (log-returns)
prices_wide <- prices %>%
pivot_wider(names_from = symbol, values_from = adjusted)
returns_daily <- prices_wide %>%
arrange(date) %>%
# log returns: log(P_t / P_{t-1})
mutate(across(all_of(tickers), ~ log(.x / lag(.x)))) %>%
select(date, all_of(tickers)) %>%
drop_na()
if (nrow(returns_daily) < 30) {
showNotification("Pocos datos disponibles. Intenta con un período más largo.", type = "warning")
return(NULL)
}
returns_matrix <- as.matrix(returns_daily[, tickers])
# Estadísticas anualizadas
mu <- colMeans(returns_matrix) * 252       # Rendimiento promedio anualizado
Sigma <- cov(returns_matrix) * 252         # Matriz de covarianza anualizada
# -----------------------------------------------------------------
# 1. Simulación de Monte Carlo para la Nube de Portafolios (N=5000)
# -----------------------------------------------------------------
N_SIMULATIONS <- 5000
mc_results <- tibble(
volatility = numeric(),
return = numeric(),
sharpe = numeric(),
weights = list()
)
for (i in 1:N_SIMULATIONS) {
# Generar pesos aleatorios (pesos largos, sin venta corta)
weights <- runif(n_assets)
weights <- weights / sum(weights) # Normalizar para que sumen 1
# Calcular Rendimiento, Volatilidad y Sharpe
ret_i <- sum(weights * mu)
vol_i <- sqrt(t(weights) %*% Sigma %*% weights)
sharpe_i <- (ret_i - rf) / vol_i
# Almacenar resultados
mc_results <- bind_rows(mc_results, tibble(
volatility = vol_i,
return = ret_i,
sharpe = sharpe_i,
weights = list(weights) # Guardamos los pesos para el tooltip
))
}
# --- Identificar los portafolios MC óptimos ---
# Portafolio MC con Máximo Sharpe
mc_max_sharpe <- mc_results %>% arrange(desc(sharpe)) %>% slice(1)
w_mc_max_sharpe <- unlist(mc_max_sharpe$weights)
# Portafolio MC con Mínima Volatilidad
mc_min_vol <- mc_results %>% arrange(volatility) %>% slice(1)
w_mc_min_vol <- unlist(mc_min_vol$weights)
# -----------------------------------------------------------------
# 2. Portafolios de Markowitz (Mínima Varianza y Máximo Sharpe)
# -----------------------------------------------------------------
# --- Portafolio de Mínima Varianza (MVP) ---
Dmat <- Sigma
dvec <- rep(0, n_assets)
A_eq <- rep(1, n_assets)
A_ineq <- diag(n_assets) # Pesos >= 0 (no short-selling)
Amat <- cbind(A_eq, A_ineq)
bvec <- c(1, rep(0, n_assets)) # Suma de pesos = 1, Pesos >= 0
sol_minvar <- tryCatch({
solve.QP(Dmat, dvec, Amat, bvec, meq = 1)
}, error = function(e) {
showNotification("Error en optimización (mínima varianza).", type = "error")
return(NULL)
})
if (is.null(sol_minvar)) return(NULL)
w_minvar <- sol_minvar$solution
ret_minvar <- sum(w_minvar * mu)
vol_minvar <- sqrt(t(w_minvar) %*% Sigma %*% w_minvar)
# --- Portafolio de Máximo Sharpe (Tangencia) ---
# Aproximación: encontrar el portafolio en la frontera con el mayor Sharpe
min_ret <- ret_minvar
max_ret <- max(mu)
target_returns <- seq(min_ret, max_ret, length.out = 40)
best_sharpe <- -Inf
best_w <- NULL
best_ret <- best_vol <- 0
frontier_df <- tibble(volatility = numeric(), return = numeric(), sharpe = numeric())
# Cálculo de la Frontera Eficiente y el Portafolio de Máximo Sharpe
for (target in target_returns) {
Aeq_f <- cbind(rep(1, n_assets), mu)
beq_f <- c(1, target)
Amat_f <- cbind(Aeq_f, diag(n_assets))
bvec_f <- c(beq_f, rep(0, n_assets))
# meq = 2: la suma de pesos es 1 Y el rendimiento es 'target'
sol <- try(solve.QP(Dmat, dvec, Amat_f, bvec_f, meq = 2), silent = TRUE)
if (inherits(sol, "try-error")) next
w <- sol$solution
ret <- sum(w * mu)
vol <- sqrt(t(w) %*% Sigma %*% w)
sharpe <- (ret - rf) / vol
# Almacenar punto de la Frontera
frontier_df <- bind_rows(frontier_df, tibble(volatility = vol, return = ret, sharpe = sharpe))
# Actualizar Máximo Sharpe
if (sharpe > best_sharpe) {
best_sharpe <- sharpe
best_w <- w
best_ret <- ret
best_vol <- vol
}
}
# --- Activos individuales ---
assets_df <- tibble(
asset = tickers,
volatility = sqrt(diag(Sigma)),
return = mu
)
# --- Resultados ---
output$status <- renderText({ "Optimización y Simulación completadas." })
list(
tickers = tickers,
assets_df = assets_df,
mc_df = mc_results,
frontier_df = frontier_df,
w_sharpe = best_w,
ret_sharpe = best_ret,
vol_sharpe = best_vol,
sharpe_ratio = best_sharpe,
w_minvar = w_minvar,
ret_minvar = ret_minvar,
vol_minvar = vol_minvar,
# Pesos de Monte Carlo óptimos añadidos para la nueva gráfica
w_mc_max_sharpe = w_mc_max_sharpe,
w_mc_min_vol = w_mc_min_vol,
rf = rf
)
})
})
# Gráfico interactivo de la Frontera
output$frontier_plot <- renderPlotly({
req(portfolio_optimization())
res <- portfolio_optimization()
# 1. Línea de Mercado de Capitales (CML)
cml_df <- tibble(
volatility = c(0, res$vol_sharpe * 2),
return = c(res$rf, res$rf + res$sharpe_ratio * res$vol_sharpe * 2)
)
# 2. Configuración de Tooltips (para la tabla de pesos de MC)
mc_tooltips <- map_chr(1:nrow(res$mc_df), function(i) {
weights <- res$mc_df$weights[[i]]
weights_text <- paste0(res$tickers, ": ", scales::percent(weights, accuracy = 0.1), collapse = "<br>")
paste0(
"<b>Portafolio Simulacdo</b><br>",
"Rendimiento: ", scales::percent(res$mc_df$return[i], accuracy = 0.1), "<br>",
"Volatilidad: ", scales::percent(res$mc_df$volatility[i], accuracy = 0.1), "<br>",
"Sharpe Ratio: ", round(res$mc_df$sharpe[i], 3), "<br><br>",
"<b>Pesos:</b><br>", weights_text
)
})
# 3. Gráfico (ggplot2)
p <- ggplot() +
# Puntos de Monte Carlo (Nube de portafolios)
geom_point(
data = res$mc_df,
aes(volatility, return, color = sharpe, text = mc_tooltips),
alpha = 0.6,
size = 1.5
) +
scale_color_gradientn(
colors = brewer.pal(9, "Spectral"),
name = "Ratio de Sharpe",
limits = c(min(res$mc_df$sharpe), max(res$mc_df$sharpe))
) +
# Línea de la Frontera Eficiente (Markowitz)
geom_line(data = res$frontier_df, aes(volatility, return), color = "black", size = 1.5) +
# Línea de Mercado de Capitales (CML)
geom_line(data = cml_df, aes(volatility, return), color = "#9333ea", linetype = "dashed", size = 1) +
# Portafolio de Mínima Varianza (MVP)
geom_point(
aes(x = res$vol_minvar, y = res$ret_minvar, text = "MVP - Mínima Varianza (Analítico)"),
color = "red",
size = 5,
shape = 17
) +
# Portafolio de Máximo Sharpe (Tangencia)
geom_point(
aes(x = res$vol_sharpe, y = res$ret_sharpe, text = paste("Portafolio Tangente (Analítico)<br>Máx. Sharpe:", round(res$sharpe_ratio, 3))),
color = "green",
size = 5,
shape = 17
) +
# Activos Individuales
geom_point(
data = res$assets_df,
aes(volatility, return, text = asset),
color = "black",
size = 3
) +
# Etiquetas
labs(
title = "Frontera Eficiente de Portafolios (Markowitz)",
x = "Volatilidad (Riesgo Anualizado, $\\sigma_p$)",
y = "Rendimiento Esperado (Anualizado, $\\mu_p$)",
caption = "Puntos: Activos individuales. Nube: Simulación Monte Carlo (coloreada por Sharpe). Línea Negra: Frontera Eficiente. Línea Púrpura: CML."
) +
scale_x_continuous(labels = scales::percent_format()) +
scale_y_continuous(labels = scales::percent_format()) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(face = "bold", hjust = 0.5),
legend.position = "bottom"
)
# Convertir a plotly
ggplotly(p, tooltip = "text") %>%
layout(hovermode = "closest")
})
# Gráfico de Distribución de Pesos de Portafolios Clave (NUEVA TAB)
output$mc_weights_plot <- renderPlotly({
req(portfolio_optimization())
res <- portfolio_optimization()
tickers <- res$tickers
# Crear un data frame con los pesos de los 4 portafolios clave
weights_plot_df <- tibble(
Activo = rep(tickers, 4),
Peso = c(
res$w_sharpe,
res$w_mc_max_sharpe,
res$w_minvar,
res$w_mc_min_vol
),
Portafolio = rep(
c("Analítico Máx. Sharpe", "MC Máx. Sharpe", "Analítico Mín. Varianza", "MC Mín. Volatilidad"),
each = length(tickers)
)
)
# Crear el gráfico de barras comparativo
p <- weights_plot_df %>%
ggplot(aes(x = Activo, y = Peso, fill = Portafolio, text = paste(
"Activo:", Activo,
"<br>Peso:", scales::percent(Peso, accuracy = 0.1)
))) +
geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
facet_wrap(~ Portafolio, ncol = 2) +
labs(
title = "Comparación de Distribución de Pesos en Portafolios Clave",
y = "Peso del Activo (%)"
) +
scale_y_continuous(labels = scales::percent_format()) +
theme_minimal(base_size = 14) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
legend.position = "none", # La leyenda se usa en facet_wrap
plot.title = element_text(face = "bold", hjust = 0.5)
)
# Convertir a plotly
ggplotly(p, tooltip = "text") %>%
layout(hovermode = "closest", showlegend = FALSE) # No mostrar leyenda innecesaria
})
# Tabla de pesos
output$weights_table <- renderDT({
req(portfolio_optimization())
res <- portfolio_optimization()
weights_df <- tibble(
Activo = res$tickers,
`Peso Máx. Sharpe (Analítico)` = round(res$w_sharpe, 4),
`Peso Mín. Varianza (Analítico)` = round(res$w_minvar, 4),
`Peso Máx. Sharpe (MC)` = round(res$w_mc_max_sharpe, 4),
`Peso Mín. Volatilidad (MC)` = round(res$w_mc_min_vol, 4)
) %>%
arrange(desc(`Peso Máx. Sharpe (Analítico)`))
datatable(
weights_df,
options = list(pageLength = 10, dom = 'tip'),
rownames = FALSE
) %>%
formatPercentage(columns = 2:5, digits = 2)
})
# Estadísticas
output$stats <- renderText({
req(portfolio_optimization())
res <- portfolio_optimization()
paste(
"Análisis de Portafolio Óptimo (Tasa Libre de Riesgo:", round(res$rf * 100, 2), "%)\n",
"--------------------------------------------------\n\n",
"Portafolio de Máximo Sharpe (Analítico):\n",
"  - Rendimiento esperado:", round(res$ret_sharpe * 100, 2), "%\n",
"  - Volatilidad (Riesgo):", round(res$vol_sharpe * 100, 2), "%\n",
"  - Sharpe Ratio:", round(res$sharpe_ratio, 3), "\n\n",
"Portafolio de Mínima Varianza (Analítico):\n",
"  - Rendimiento esperado:", round(res$ret_minvar * 100, 2), "%\n",
"  - Volatilidad (Riesgo):", round(res$vol_minvar * 100, 2), "%"
)
})
}
# Run the application
shinyApp(ui = ui, server = server)
shiny::runApp()
proxy_url <- "http://proxybg:3128"
Sys.setenv(http_proxy = proxy_url, https_proxy = proxy_url, ftp_proxy = proxy_url)
runApp()
shiny::runApp()
proxy_url <- "http://proxybg:3128"
Sys.setenv(http_proxy = proxy_url, https_proxy = proxy_url, ftp_proxy = proxy_url)
runApp()
